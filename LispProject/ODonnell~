;;;; -*- Mode: Lisp; -*-

(defstruct person 
  (name nil)
  (parents (list))
  (children (list))
  (spouses (list))
)



(defun storeperson (name struct tree)
;;;"Students need to write this! This should enter the person structure in STRUCT into the hashtable in FAMY-TREE with the key in SYMBOL-NAME."
(setf (gethash name tree) struct))


(defun personstruct (name tree)
 ;;"Returns a structure of type person corresponding to the key SYMBOL-NAME in the hashtable FAMILY-TREE. If there is no one in the tree with the name in SYMBOL-NAME, returns NIL."
  (gethash name tree nil))

(defun addspouse (spouse-name p)
  (setf (person-spouses p) (cons spouse-name (person-spouses p)))
;;;(setf (person-spouses p) (sort (person-spouses p) #'string<
)

(defun addchild (child-name p)
  (setf (person-children p) (cons child-name (person-children p)))
)

(defun getparents (p)
  (person-parents (gethash p tree)))

(defun getchildren (p)
  (person-children (gethash p tree)))

(defun getspouses (p)
  (person-spouses (gethash p tree)))

(defun siblings (p tree)
(let ((parent1 (personstruct (first (person-parents p)) tree))
      (parent2 (personstruct (second (person-parents p)) tree)))
(when parent1
  (sort (remove (person-name p)
 (delete-duplicates
  (append (person-children parent1) (person-children parent2)) :test #'equal)) #'string<))))

(defun ancestors (p tree)
  (let ((parent1 (personstruct(first (person-parents p))tree ))
        (parent2 (personstruct (second (person-parents p))tree )))
    (if (null parent1)
         nil
       (append (list(person-name parent1) (person-name parent2)) (ancestors parent1 tree )(ancestors parent2 tree )))))

;;; is funcitons
(defun isspouse (p1 p2)                              
(let ((spouse nil)) ; returns t true or nil false
(if  (member (person-name p1) (person-spouses p2) :test #'equal) (setf spouse t))
(if spouse t nil))) ; If spouse, spouse is true, else spouse is false 

 

(defun ischild (p1 p2)
  (let ((child nil))
    (if (member (person-name p1) (person-children p2) :test #'equal) (setf child t))
    (if child t nil)))
 

(defun issibling (p1 p2 tree)
(let ((sibling nil))
  (if (member (person-name p1) (siblings p2 tree) :test #'equal) (setf sibling t))
(if sibling t nil)))

 

(defun iscousin (p1 p2 tree)
(let ((cousinbool nil) (directrel nil))
(if (equalp (person-name p1) (person-name p2)) (setf directrel t)) 
(let ((ancestors2 (ancestors p2 tree)) (ancestors1 (ancestors p1 tree)))
(if (or (member(person-name p1) ancestors2) (member (person-name p2) ancestors1)) (setf directrel t))
(when (not directrel)
  (loop for person in ancestors1 doing (if (member person ancestors2 :test #'equal) (setf cousinbool t)))))
  (if cousinbool t nil)))

(defun isancestor (p1 p2 tree)
  (let ((ancestorbool nil))
    (if (member (person-name p1) (ancestors p2 tree) :test #'equal) (setf ancestorbool t))
    (if ancestorbool t nil)))
 

(defun isunrelated (p1 p2 tree)
(let ((unrelatedbool t))
(if (or (ischild p1 p2) (ischild p2 p1)) (setf unrelatedbool nil)) ; if one person is a child of the other return false
(if (issibling p1 p2 tree) (setf unrelatedbool nil))
(if (iscousin p1 p2 tree) (setf unrealtedbool nil))
(if (= (p1) (p2) #'string) (setf unrealtedbool t))
(if (or (isancestor p1 p2 tree) (isancestor p2 p1 tree)) (setf unrelatedbool nil))
(if unrelatedbool t nil)))

(defun getcousins( )

)
(defun getunrelated( )

) 
  


(defun equerychild (parent1 parent2 child tree)
;;; Start by creating 
(let ((p1 (personstruct parent1 tree)) (p2 (personstruct parent2 tree)) (chi (personstruct child tree)))
              ; Test to see if tree, store if not
             (if (not (string= (personstruct parent1 tree)))
                (setf p1 (storeperson parent1 (make-person :name parent1) tree))
                )
              (if (not (string= (persontstruct parent2  tree)))
                  (setf p2 (storeperson parent2 (make-person :name parent2) tree))
                )
              (if (not(isspouse p1 p2))
                  (progn
                    (addspouse (person-name p1) p2)
                    (addspouse (person-name p2) p1)
                  ))
           (setf chi (storeperson child (make-person :name child) tree))  ;create child
           (addchild
))

(defun equerynochild(person1 person2 tree)
(let ((p1 (personstruct person1 tree)) (p2 (personstruct person2 tree)))
  (if (not (string= (personstruct parent1 tree)))
      (setf p1 (storeperson parent1 (make-person :name parent1) tree)) )
   (if (not (string= (persontstruct parent2  tree)))
   (setf p2 (storeperson parent2 (make-person :name parent2) tree)) )
   (if (not (isspouse p1 p2)) ; if they are not spouses already 
       (progn
              ))
 ))

(defun xquery (person1 relation person2 tree)
(let  ((p1 (personsruct person1 tree)) (p2 (personstruct person2 tree)))
 (cond ((string= (relation) "Spouse")
        (if (isspouse p1 p2) (format t "Yes~%") (format t "No~%")))
   ((string= (relation) "Child")
    (if (ischild p1 p2) (format t "Yes~%") (format t "No~%")))
    ((string= (relation) "Sibling")
     (if (issibling p1 p2 tree) (format t "Yes~%") (format t "No~%")))
    ((string= (relation) "Ancestor") 
    (if (isancestor p1 p2 tree) (format t "Yes~%") (format t "No~%")))
    ((string= (relation) "Cousin") 
    (if (iscousin p1 p2 tree) (format t "Yes~%") (format t "No~%")))
   ((string= (relation) "Unrelated")
      (if (isunrelated p1 p2 tree) (format t "No~%") (format t "Yes~%")))))
)

(defun wquery (relation p tree)
(let (p1 (personstruct p tree))
   (cond ((string= (relation) "Spouse")      )
                      ((string= (relation) "Child")  )
                      ((string= (relation) "Sibling")     )
                      ((string= (relation) "Ancestor")  )
                      ((string= (relation) "Cousin")   )
                      ((string= (relation) "Unrelated")
                       )))
)



(defun family()
  (let ((tree (make-hash-table :size 1000 :test #'equal)))
 (let ((line nil) (tokens nil) (p1 nil) (p2 nil) (p3 nil) (relation nil))
(let (line (read *standard-input*))
   (loop for line
         until (eq line nil)
         do (                       
       (cond ((string= (first line) "E" )
            ;;;Person creation and spouse children assignment here
              (format t "~a~%" line)
              (if (not (equal (fourth line) nil)) ; if fourth word != nil
              (equerychild (second line) (third line) (fourth line))
                (equerynochild(second line) (third line) tree)
              )                                                                                                                                                                                                   
            ((string= (first line) "X")
             ;Xquery stuff here
              (format t "~a~%" line); prints line
            (x query (second line) (third line) (fourth line) tree))
             
            ((string= (first line) "W")
            ;Wquery stuff here
              (format t "~a~%" line)
              (wquery (second line) (third line) (tree))
               ))
))))))
    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
        
